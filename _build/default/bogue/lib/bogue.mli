(* !!!!!!!!! autogenerated, don't edit !!!!!!!!! *)



(** General purpose GUI (Graphical user interface) library for Ocaml.

   Bogue is a lightweight and fast GUI for developing desktop applications,
   games, or for easy debugging of non-GUI programs.

   Bogue is entirely written in {{:https://ocaml.org/}ocaml} except for the
   hardware accelerated graphics library {{:https://www.libsdl.org/}SDL2}.

@version 20220323

@author Vu Ngoc San

*)

(** {3 Quick start}

 For a quick start, see Bogue's {{:Principles.html}general principles}, and the
   minimal {{!example}example}.

    The main modules are

    - {!Main} (creating, running, and quitting your app),
    - {!Layout} (arranging widgets to form sophisticated interfaces like table,
    menus, etc.) and
    - {!Widget} (the building blocks, like labels, buttons, etc.).

   {!indexlist}


*)

(* ---------------------------------------------------------------------------- *)

(** {1 List of Modules}

The only thing that [open Bogue] does is to bring these modules into your
   namespace. The have quite common names, so beware of conflict. In case of
   doubt, don't open [Bogue], and access to the modules by using the [Bogue]
   prefix, for instance [Bogue.Widget.label]. The {!Widget} and {!Layout}
   modules are probably the ones that you will find yourself using the most, so
   it's a good idea to alias them:

{[module W = Bogue.Widget
module L = Bogue.Layout]}


{%html:<br><br>%}

*)



(** Theming variables

    A number of variables control the appearance of your Bogue application. They are called {%html:<a href="#path">Theme variables</a>%}.
 They take effect when you start your application up (no need to recompile).
For quick experimentation, they can be modified as environment variables, for instance:
{v
export BOGUE_SCALE=2.5
v}
They can also be saved in configuration files, and you may organize as many config files as you want into {e themes}.

{3:config Where are the config files?}

The config files are all called [bogue.conf]. Several locations are used.
    Upon installing Bogue, a system wide Bogue share directory is created. If you used an {b opam} install, this will be
{v
$(opam var share)/bogue
v}
The share directory contains a [themes] directory, which itself contains a [default] dir.
This where the default configuration file, resides.

However, {b if you want to modify the themes}, it is advisable to create your own Bogue share dir.
    This personal Bogue dir should be [$(XDG_CONFIG_HOME)/bogue].
    (If [$XDG_CONFIG_HOME] is not defined in your system, you may use [$HOME/.config/bogue]).
So, this is what you can do for creating your personal Bogue dir for the first time:
{v
cp -r $(opam var share)/bogue $HOME/.config/bogue
v}


- Each theme has its own directory inside the Bogue share dir, in which there is a  [bogue.conf] file where the
  Theme variables are defined.
- A global user config file [$HOME/.config/bogue/bogue.conf] overrides
  the theme files.
- A [bogue.conf] file in the same directory as the executable overrides the other
  config files.
- The syntax of the config file is [VARIABLE = value], one entry per line.
  Notice the spaces surroundind [=]. Comment lines starting by [#] are ignored.
  For instance:
{v
## BOGUE version 20220115
THEME = dark
BACKGROUND = color:azure
v}

    The first line <code>## BOGUE version XXX</code> is compulsory.

{3:list Here is the list of Theme variables:}

- [BACKGROUND]: the default background for all windows. It can be a color
  (eg. [color:darkturquoise] or [color:#00CED1]), or an image file
    (eg. [file:myimage.png]). See {%html:<a href="#path">below</a>%}
     for how to specify paths.
- [BG_COLOR]: A background color (eg. [darkturquoise], or [#00CED1])
  that is used by default by some widgets/layouts.
  It should be clearly visible over the [BACKGROUND].
- [BUTTON_COLOR_ON]: the color of active buttons.
- [BUTTON_COLOR_OFF]: the color of inactive buttons.
- [CHECK_ON]: the image used for the 'checked' icon. It can be a file
  (eg. [myimage.png]) or a font-awesome icon (eg. [fa:check-square-o]).
- [CHECK_OFF]: the image used for the 'unchecked' icon. See [CHECK_ON].
- [CURSOR_COLOR]
- [DIR]:  The directory containing the themes subdirectories. Default: auto   detected at startup, usually [$HOME/.config/bogue/themes]
- [FA_DIR]: The fontawesome directory inside [DIR/common/].
- [FAINT_COLOR]: A non-obstrusive color for disabled options or
  text of little importance.
- [LABEL_COLOR]: The color for text or icon labels.
- [LABEL_FONT]: path of a TTF font for text labels. Eg: [Ubuntu-R.ttf].
- [LABEL_FONT_SIZE]: integer, eg [14].
- [LOG_TO_FILE]: if "false", all log messages will appear on the console. If "true", the messages are instead sent to a log file, typically in the "/tmp" directory.
- [MENU_HL_COLOR]: the color for highlighting selected menu entries.
- [MENU_BG_COLOR]
- [MONO_FONT]: monospace font.
- [ROOM_MARGIN]
- [SCALE]: global scale (any non-negative float). For instance if [SCALE = 2.],
  all dimensions given to Bogue functions will be multiplied by 2 before
  rendering to obtain
  the hardware size in pixels.
  If set to [0.] or not specified, it is autodetected to match your screen DPI
  (using [xdpyinfo], if present).
- [SEL_BG_COLOR]: background color for selected items in lists.
- [SEL_FG_COLOR]: text color for selected items in lists.
- [SMALL_FONT_SIZE]: integer. Used for instance for tooltips popups.
- [TEXT_COLOR]: color of standard text displays.
- [TEXT_FONT]
- [TEXT_FONT_SIZE]
- [THEME]: the name of the theme to use.
  It should be the name of the directory within the [themes] dir.
  As soon as this variable is set, all variables from that theme
  are loaded and override previously defined variables.
  If not specified, the default theme is initially loaded.

All variables with "COLOR" in their name can be specified either with RGB hexadecimal like [#00CED1], or with a standard html name like [darkturquoise], see {{:https://www.rapidtables.com/web/color/html-color-codes.html}this color table}.

All variables can be overriden by setting the corresponding
environment variables, prepending "BOGUE_". For instance:
{v
export BOGUE_LABEL_COLOR=forestgreen
v}

{%HTML:<br>%}


{2:path How to load assets (images, sounds, etc.)}

When specifying a file to load, for instance
{v
BACKGROUND = file:background.png
v}
you need to specify where the file should be searched. Here are the rules:

First, the file is searched in current directory,
    then in the current theme's directory (for instance [$HOME/.config/bogue/themes/default]),
unless the file string starts with [/], in which case it should be an
absolute path (eg. [file:/home/alice/myimage.png]).
Finally, if the file string starts with [%], for instance [file:%assets/images/bob.png],
then the [%] char is replaced by the Bogue dir, for instance [file:/home/bob/.config/bogue/assets/images/bob.png].


{5 {{:graph-b_theme.html}Dependency graph}} *)
module Theme : sig

  (** {2 Accessing Theme variables}

     Theme variables are essentially for Bogue's internal use, but sometimes it
     can be useful to access their values. See above for their description. *)

  val room_margin : int

  val scale_int : int -> int
(** Conversion: Bogue dimension -> hardware pixel dimension. The latter is
   obtained by multiplying by [SCALE]. *)

end (* of Theme *)

(* ---------------------------------------------------------------------------- *)


(** Utilities

    This module contains several utilities, in particular for debug logs.

{5 {{:graph-b_utils.html}Dependency graph}}
*)
module Utils : sig

  (** {2 Debugging} *)

  val printd : int -> ('a, unit, string, unit) format4 -> 'a
  (** For instance [printd debug_warning "The value x=%u is too big" x] will
     print a message in the console only if the {!debug} variable contains the
     [debug_warning] flag. *)

  val debug : bool ref
  val debug_code : int ref
  (** Logical {e ored} of [!debug] with debug flags (below) controls the amount
     of debuging. *)

  (** {3 Binary masks (=flags) for debugging messages.} *)

  val debug_thread : int
  val debug_warning : int
  val debug_graphics : int
  val debug_error : int
  val debug_io : int
  val debug_memory : int
  val debug_board : int
  val debug_event : int
  val debug_custom : int

  (** {2 Maths} *)

  val pi : float

  val round : float -> int
  (** Round float to nearest integer. *)

  val imax : int -> int -> int
  (** [imax a b] returns max([a], [b]). *)

  val imin : int -> int -> int
  (** [imin a b] returns min([a], [b]). *)

  (** {2 Tsdl Result} *)

  val go : 'a Tsdl.Sdl.result -> 'a
  (** Transform a [result] into a standard value, or fail with an error. Used
      only for SDL functions. *)

  (** {2 Options}

      Monadic style operations on optional variables. *)

  val map_option : 'a option -> ('a -> 'b) -> 'b option

  val do_option : 'a option -> ('a -> unit) -> unit

  val default : 'a option -> 'a -> 'a

  exception None_option

  val remove_option : 'a option -> 'a
  (** Warning: [remove_option None] will raise the {!None_option} exception. *)

  (** {2 Others} *)

  val run : (unit -> 'a) -> 'a
  (**  [run f] is equivalent to [f ()]. *)

end (* of Utils *)

(* ---------------------------------------------------------------------------- *)


(** Time in msec

{5 {{:graph-b_time.html}Dependency graph}}
*)
module Time : sig
  type t = int

  val now : unit -> t
  (** Time elapsed from the initialization of SDL (roughly, since the start of
      your program). *)

  val adaptive_fps : int -> (unit -> unit) * (unit -> unit)
  (** Create helper functions to help controlling the frame rate of the graphics
      loop. This is only useful if you have your own graphics loop, and do not
      use {!Main.run}.

      [adaptive_fps 60] returns two functions [start,fps]. The statement [start ()]
      will start the timing. At each iteration of your loop, you should call
      [fps ()], which will try to sleep long enough to achieve the desired 60FPS
      rate. It works on average: if some frames take longer, it will shorten the
      next frame to keep up. However, it tries to be nice to the CPU: even if one
      is really too slow, it will guarantee a 5ms sleep to the CPU and {e not}
      try to keep up. *)

end (* of Time *)

(* ---------------------------------------------------------------------------- *)

(** Global variables with mutex

   In a GUI, it is quite likely that a thread has to modify a variable owned by
   another thread. This is particularly true in Bogue. In order to protect
   against concurrent access to a shared variable, one should use a special kind
   of variable. This is the goal of this module.

   {b Warning:} working with threads is subtle, and using {!Var} will not
   magically make all problems disappear. In particular if two variables want to
   access each other, you can end up into a stall, and freeze your program.
   This can happen more often that one thinks, because a Var may contain a
   {!Layout}, and we know that sometimes layouts want to modify themselves...

{5 {{:graph-b_var.html}Dependency graph}} *)
module Var : sig
  type 'a t

  val create : 'a -> 'a t
  (** [create v] returns a Var with initial value [v]. *)

  val get :  'a t ->  'a

  val set : 'a t ->  'a -> unit
    (** [set v value] waits until no thread is accessing the Var [v]
        and then sets its value to [value]. *)

end (* of Var *)

(* ---------------------------------------------------------------------------- *)

(** Delayed actions

{5 {{:graph-b_timeout.html}Dependency graph}}
*)
module Timeout : sig
  type t

  val add : int -> (unit -> unit) -> t
  (** [add delay action] will execute
     [action ()] after the delay of [delay] ms.
     @return the Timeout element.

     Warning: don't expect the delay to be
     exact at the ms. The precision cannot be better than what the
     framerate imposes, {e i.e.} usually about 16ms. *)

  val cancel : t -> unit
    (** Cancel the Timeout. *)
end (* of Timeout *)

(* ---------------------------------------------------------------------------- *)

(** Dealing with events

Events are simply SDL events, plus a few additional events. They are also used
   for primitive communication between threads.

Events are detected by Layouts, and then sent to the resident Widget. Finally,
   the Widget decides what to do with the events. There is one exception: the
   {!startup} event is directly sent to all Widgets.


{5 {{:graph-b_trigger.html}Dependency graph}} *)
module Trigger : sig
  type t = Tsdl.Sdl.event_type

  (** {2 SDL events} *)

  val text_input : t
  (** Same as Tsdl.Sdl.Event.text_input *)

  val key_down : t
  (** Same as Tsdl.Sdl.Event.key_down *)

  val key_up : t
  (** Same as Tsdl.Sdl.Event.key_up *)

  (** {2 Special Bogue events} *)

  val startup : t
  (** The [startup] event is sent to all Widgets when the Bogue mainloop is
     started using {!Main.run}. *)

  val mouse_enter : t
  (** The [mouse_enter] event is triggered when the pointer (mouse motion, or
     finger touch -- but not finger drag) enters a new layout. *)

  val mouse_leave : t
  (** Similar to {!mouse_enter}, when the pointer leaves the layout. *)

  val var_changed : t
  (** The [var_changed] event can be sent to notify that some widget made a
     change to a global variable. *)

  val update : t
  (** Currently the [update] event is more or less equivalent to
     [var_changed]. This might change in future versions. *)

  val buttons_down : t list
  (** A list of events containing the mouse_button_down event, and the
     finger_down event. *)

  val buttons_up : t list
  (** A list of events containing the mouse_button_up event, and the
     finger_up event. *)

  val pointer_motion : t list
  (** A list of events containing the mouse_motion event, and the finger_motion
     event. *)

  (** {2 Using events for terminating threads} *)

  val should_exit : Tsdl.Sdl.event -> bool
  (** Tell if the current thread should exit. This should only be called within
     a widget action. The event should be the event passed to the action
     function. A well programmed action should check this event to decide if it
     should exit. *)
  (* à déplacer dans Widget/connection ? *)

  val will_exit : Tsdl.Sdl.event -> unit
  (** A nice thread should do this just before terminating. May be suppressed in
      future versions. *)

  val nice_delay : Tsdl.Sdl.event -> float -> unit
  (** [nice_delay ev t] Wait during a delay ([t] seconds), but quit anyway when
     {!should_exit}[ ev] is true. *)

  val push_quit : unit -> unit
  (** Send the SDL_QUIT event, as if the user clicked on the close button of the
     last existing window. It will in principle raise the {!Main.Exit}
     exception and hence exit the mainloop. *)

  (** {2 SDL Misc} *)
  val wait_for : ?timeout:float -> ?ev:Tsdl.Sdl.event -> (unit -> bool) -> unit

  (** {2 SDL events} *)

  type sdl_event =
    [ `App_did_enter_background
    | `App_did_enter_foreground
    | `App_low_memory
    | `App_terminating
    | `App_will_enter_background
    | `App_will_enter_foreground
    | `Clipboard_update
    | `Controller_axis_motion
    | `Controller_button_down
    | `Controller_button_up
    | `Controller_device_added
    | `Controller_device_remapped
    | `Controller_device_removed
    | `Dollar_gesture
    | `Dollar_record
    | `Drop_file
    | `Finger_down
    | `Finger_motion
    | `Finger_up
    | `Joy_axis_motion
    | `Joy_ball_motion
    | `Joy_button_down
    | `Joy_button_up
    | `Joy_device_added
    | `Joy_device_removed
    | `Joy_hat_motion
    | `Key_down
    | `Key_up
    | `Mouse_button_down
    | `Mouse_button_up
    | `Mouse_motion
    | `Mouse_wheel
    | `Multi_gesture
    | `Quit
    | `Sys_wm_event
    | `Text_editing
    | `Text_input
    | `Unknown of int
    | `User_event
    | `Window_event
    | `Display_event
    | `Sensor_update
    ]

  type bogue_event =
    [ `Bogue_startup
    | `Bogue_stop
    | `Bogue_stopped
    | `Bogue_mouse_at_rest
    | `Bogue_mouse_enter
    | `Bogue_mouse_leave
    | `Bogue_var_changed
    | `Bogue_keyboard_focus
    | `Bogue_mouse_focus
    | `Bogue_remove_layout
    | `Bogue_update
    | `Bogue_sync_action
    | `Bogue_redraw ]

  val event_kind : Tsdl.Sdl.event -> [sdl_event | bogue_event]
  (** Union of {!sdl_event} and {!bogue_event} *)

end (* of Trigger *)

(* ---------------------------------------------------------------------------- *)

(** Basic audio mixer for sound effects

This simple audio mixer makes it possible to play quick sounds, for instance
   when clicking on buttons, or for game sounds effects.

Only WAV files are supported. For playing MP3 music, and for more options, it is
   advisable to use the SDL_Mixer library.

{e Remark:} This module is essentially independent of the rest of Bogue, so its
   source can, with very few modifications, be used for any SDL application.

{5 {{:graph-b_mixer.html}Dependency graph}} *)
module Mixer : sig
  type t
  type sound =  (int, Bigarray.int16_signed_elt) Tsdl.Sdl.bigarray
  type repeat = Repeat of int | Forever
  (* How many times we should repeat the sound. *)

  val test : unit -> unit

  val init : unit -> string option
  (** Initialize SDL audio.
      @return the name of the audio driver. *)

  val create_mixer : ?tracks:int -> ?freq:int -> string option -> t
  (** Create the mixer an open sound device. Only [s16le] format is supported by
      the callback at this time. *)

  val load_chunk : t -> string -> sound
  (** Load a WAV file. *)

  val play_chunk : ?track:int ->
    ?effects:(sound -> unit) list ->
    ?volume:float -> ?repeat:repeat -> t -> sound -> int option
  (** Play chunk on the desired track number. If [track] is not specified, find
     an available track. By default [repeat = Repeat 1].
     @return chosen track number, or None *)

  val change_volume : float -> sound -> unit
  (** Multiply sound intensity by a float factor *)

  val pause : t -> unit
  val unpause : t -> unit
  val close : t -> unit

end (* of Mixer *)

(* ---------------------------------------------------------------------------- *)

(** Synchronized execution queue.

   Any action can be pushed to this FIFO queue, in order to be executed by
   Bogue's main loop at the start of the next graphical frame.

   For any action that is not super urgent, it is a good idea to use this `Sync`
   module, instead of launching the action directly from a thread that may be
   difficult to control. In this way, we ensure that the action is not executed
   in the middle of rendering the graphics, or between various modifications of
   the board (events, keyboard focus, etc.).

{5 {{:graph-b_sync.html}Dependency graph}} *)
module Sync : sig

  val push : (unit -> unit) -> unit
(** [push action] registers the [action] to be executed by the mainloop at the
   start of the next frame, or at a subsequent frame if the queue is already
   large. *)

end (* of Sync *)

(* ---------------------------------------------------------------------------- *)

(** Low-level graphics and colors

This module is internally used for low-level graphics and a thin layer over
   Tsdl.

The public API is mainly useful for Color management. There are also some helper
   functions for drawing into an {!Sdl_area}.

{5 {{:graph-b_draw.html}Dependency graph}} *)
module Draw: sig
  type canvas
  (** Contains the hardware information for drawing (SDL renderer and window). *)

  type texture = Tsdl.Sdl.texture

  (** {2 Initialization and shutdown} *)

  val quit : unit -> unit
  (** Cleanup and quit SDL. *)

  (** {2 Colors} *)

  type rgb = int * int * int
  (** red, green and blue values are integers in the range [0..255] *)

  type color = int * int * int * int
  (** r,g,b,a *)

  type fill =
    | Pattern of texture
    | Solid of color

  (** {3 Predefined colors} *)

  val black : rgb
  val grey : rgb
  val pale_grey : rgb
  val dark_grey : rgb
  val white : rgb
  val red : rgb
  val blue : rgb
  val green : rgb
  val magenta : rgb
  val cyan : rgb
  val yellow : rgb
  val sienna : rgb

  val label_color : rgb

  val none : color
  (** [none = (0,0,0,0)] is completely transparent black. *)

  (** {3 Creating colors} *)

  val opaque : rgb -> color
  val transp : rgb -> color
  val lighter : color -> color
  val darker : color -> color
  val set_alpha : int -> rgb -> color
  val random_color : unit -> color
  val find_color : string -> rgb
  (** Convert a string of the form ["grey"] or ["#FE01BC"] to a rgb code
     [(r,g,b)]. Color names are taken from
     {{:https://www.rapidtables.com/web/color/html-color-codes.html}here}. *)

  val pale : rgb -> rgb

  (** {3 Using colors} *)

  val set_color : Tsdl.Sdl.renderer -> color -> unit
  (** Equivalent to [Sdl.set_render_draw_color]. *)

  (** {2:drawing_functions Drawing functions}

      These functions can be used to draw onto an {!Sdl_area.t}. *)

  val to_pixels : (int * int) -> (int * int)
  (** Convert BOGUE logical coordinates into hardware pixel coordinates. This
     takes into account both the {!Theme} [SCALE] and the high-dpi scaling of
     some systems (mac OS retina, iOS). *)

  val line : ?thick:int -> Tsdl.Sdl.renderer ->
    color:color -> x0:int -> y0:int -> x1:int -> y1:int -> unit

  val rectangle : ?thick:int -> Tsdl.Sdl.renderer -> color:color ->
    w:int -> h:int -> x:int -> y:int -> unit
  (** [rectangle renderer ~color ~thick ~w ~h ~x ~y] draws a rectangle with
     given line thickness. The coordinate of the top left corner is
     [(x,y)]. The size (including the thick line) is [(w,h)]. *)

  val circle : ?thick:int -> Tsdl.Sdl.renderer ->
    color:color -> radius:int -> x:int -> y:int -> unit
  (** [circle renderer ~width ~color ~radius ~x ~y] draws a circle with given
     line thickness, centered at [(x,y)], with given [radius]. *)

  (** {2 Layers} *)

  (** Layers are used to decide the order of drawing: which graphical elements
     (layouts) should be below, which should be above. For the most part, you
     don't have to access them directly. *)
  type layer

  val use_new_layer : unit -> unit
  (** Use this when you want to switch to a completely different set of layers,
      typically when you want to draw on another window. *)

  (** {2 Misc} *)

  type align =
    | Min
    | Center
    | Max

  val unscale_size : int * int -> int * int
  (** Transform a size (W,H) in physical pixels into 'logical' pixels (w,h),
     which are used for layouts. This is done by dividing by the {!Theme}
     [SCALE] variable. *)

  val set_system_cursor : Tsdl.Sdl.System_cursor.t -> unit
  (** Set the mouse cursor to be the standard system cursor.  Internally, this
      first creates an SDL system cursor (or use a previously created one). *)

end (* of Draw *)

(* ---------------------------------------------------------------------------- *)

(** Mouse and touchscreen information

All positions are given in logical pixels, not hardware pixels (see the {!Theme}
   [SCALE] variable).

{5 {{:graph-b_mouse.html}Dependency graph}} *)
module Mouse : sig

  val pointer_pos : Tsdl.Sdl.event -> int * int
  (** Return the pointer current position. This works both for mouse and
     touchscreen. *)

  val pos : unit -> int * int
  (** Get current mouse position. *)

  val window_pos : Tsdl.Sdl.window -> int * int
(** Return the mouse position with respect to the given window, using window
   position if necessary. *)

  val button_pos : Tsdl.Sdl.event -> int * int

  val finger_pos : Tsdl.Sdl.event -> float * float


end (* of Mouse *)

(* ---------------------------------------------------------------------------- *)


(** Transform variables

    Transform variables are a way to share a common data between two widgets,
   when the data has a different meaning (or even a different type) for each
   widget. One widget holds the original value, and the other widget needs to
   apply a {e transformation} each time it wants to read or modify the value.

    For instance you want to share a bank account [b] between Alice in France
   and Bob in the USA. The value is stored by Alice in EUR, and when Bob does
   [get b], he gets the value in USD. Similarly, if he does [set b 50] to put
   50USD on the account, then Alice's value will automatically have the amount
   in EUR.

    What is interesting is that the transformation functions can also have {e
   side-effects}. For instance, send an email each time Bob or Alice modifies
   the amount.

    A more prosaic example would be a slider which shares its value as an
   integer between 0 and 100, and another widget which needs to read/save this
   value as a float between 0 and 1, and each one of them gets notified when the
   other changes the value.

{5 {{:graph-b_tvar.html}Dependency graph}} *)
module Tvar : sig
  type ('a, 'b) t
  (** a transform variable of type [('a,'b)] is a variable of type ['b] attached to
     a variable of type ['a Var.t] by a bi-directional transformation. *)

  val create : 'a Var.t -> t_from:('a -> 'b) -> t_to:('b -> 'a) -> ('a, 'b) t
  val get : ('a, 'b) t -> 'b
  val set : ('a, 'b) t -> 'b -> unit

end (* of Tvar *)

(* ---------------------------------------------------------------------------- *)

(** Animated variables

    An Avar.t is a variable that evolves in time. It is updated at every frame
   ({e i.e.} every iteration of the main loop). Bogue uses Avars for animations.

{5 {{:graph-b_avar.html}Dependency graph}} *)
module Avar : sig
  type 'a t

  type callback = unit -> unit

  (** {2 Avar creation} *)

  val create : ?duration:Time.t ->
    ?init:callback ->
    ?ending:callback ->
    ?finished:bool -> ?update:('a t -> float -> 'a) -> 'a -> 'a t
  (** Generic Avar creation. If [finished = true], the var never gets further
     updated, {e ie} behaves like a normal variable. Otherwise, the [update]
     parameter is compulsory.

     @param update is a function such that [update v s : 'a] should give the
     value of the Avar [v] at the time [s]. The meaning of the time [s] is
     described in {!progress}. *)

  val fromto : ?duration:int -> ?ending:callback -> int -> int -> int t
  (** [fromto x1 x2] creates a integer Avar.t with initial value [x1] and, as
      time elapses, moves continuously to [x2], with a final slowdown. *)

  (** {2 Avar information} *)

  val progress : 'a t -> float
  (** [progress v] is a float in \[0,1\] giving the percentage of the animation
     when the last [v.value] was computed. In case of infinite animation, this
     is just the elapsed Time (in ms). *)

  (** {2 Misc} *)

  type direction =
    | No
    | Left
    | Right
    | Top
    | Bottom
    | TopLeft
    | TopRight
    | BottomLeft
    | BottomRight
    | Random
end (* of Avar *)

(* ---------------------------------------------------------------------------- *)

(** Unions of ranges of integers

{3:selection_example Example}

We define two sets, [s=[0..5; 10..20]] and [r=[4..15]],
and we compute their union and intersection.

{[
open Bogue.Selection;;
# let s = of_list [(0,5); (10,20)];;
val s : t = <abstr>
# sprint s;;
- : string = "{0..5, 10..20}"
# let r = of_list [(4,15)];;
val r : t = <abstr>
# sprint (union s r);;
- : string = "{0..20}"
# sprint (intersect s r);;
- : string = "{4..5, 10..15}"
]}

{5 {{:graph-b_selection.html}Dependency graph}}
 *)
module Selection : sig
  type t
  val to_list : t -> (int * int) list
  val of_list : (int * int) list -> t
  val mem : t -> int -> bool
  val toggle : t -> int -> t
  val remove : t -> int -> t
  val add : t -> int -> t
  val union : t -> t -> t
  val intersect : t -> t -> t
  val sprint : t -> string
  val iter : (int -> unit) -> t -> unit

end (* of Selection *)

(* ---------------------------------------------------------------------------- *)

(** {2 Widgets}

    Widgets are building blocks of the GUI. They also receive all events (mouse
   focus, etc.) and contain the {e intelligence} of your GUI, through {e
   connections} (or callbacks, see {!Widget.connection}). However, in order to
   be displayed, they need to be packed into {e layouts} ({!Layout.t}).

   The main module for dealing with widgets is {!Widget}.
*)

(** Image widget

{5 {{:graph-b_image.html}Dependency graph}}
 *)
module Image : sig
  type t

  val create : ?width:int -> ?height:int -> ?noscale:bool -> ?bg:Draw.color -> string -> t
  (** [create "image.jpg"] will load the image ["image.jpg"]. The actual load
     occurs only once, on the first time the image widget is effectively
     displayed. The image is then stored in a texture. All
     {{:https://www.libsdl.org/projects/SDL_image/}Sdl_image} image formats are
     supported.

     The file "image.png" will be search in the current Theme
     directory. Absolute paths starting with "/" can also be used.

   @param noscale if [true], the image will appear at the original hardware
     pixel size. By default, [noscale=false] and the image is scaled using the
     {!Theme} [SCALE] variable. *)

  val create_from_svg : ?width:int -> ?height:int -> ?bg:Draw.color -> string -> t
(** Load an svg image. This requires the [rsvg] or [rsvg-convert] program.

    {e Remark:} With SDL_Image >= 2.0.2, one can use {!create} to load SVG
   files, but the size is not correctly handled (the image will be rendered at
   its 'internal SVG size', and {e then} scaled, which may result in poor
   accuracy).

   *)

end (* of Image *)

(* ---------------------------------------------------------------------------- *)

(** Line and box styles

{5 {{:graph-b_style.html}Dependency graph}}
 *)
module Style : sig
  type t

  (** not implemented *)
  type line_style =
    | Solid
    | Dotted of (int * int)

  type line
  type border
  type shadow
  type gradient
  type background =
  | Image of Image.t (** pattern image *)
  | Solid of Draw.color
  | Gradient of gradient

  val create : ?background:background -> ?border:border ->
    ?shadow:shadow -> unit -> t
  val empty : t

  val of_bg : background -> t
  val of_border : border -> t
  val of_shadow : shadow -> t
  val with_bg : background -> t -> t
  val with_border : border -> t -> t
  val with_shadow : shadow -> t -> t

  (** {2 Constructing backgrounds} *)

  val theme_bg : background
  val color_bg : Draw.color -> background
  val opaque_bg : Draw.rgb -> background
  val image_bg : Image.t -> background
  val gradient : ?angle:float -> Draw.color list -> background
  val hgradient : Draw.color list -> background
  val vgradient : Draw.color list -> background

    (** {2 Constructing borders} *)

  val mk_line : ?color:Draw.color -> ?width:int ->
    ?style:line_style -> unit -> line
  val mk_border : ?radius:int -> line -> border
  (** Note: currently, a border with positive [radius] is not compatible with a
     transparent background. *)
  (* One could optionaly make it possible by using [mask_texture] instead of
     [fast_mask_texture] in box.ml *)

  (** {2 Constructing shadows} *)

  val mk_shadow : ?offset:int * int -> ?size:int -> ?width:int ->
    ?radius:int -> unit -> shadow

end (* of Style *)

(* ---------------------------------------------------------------------------- *)

(** One-line text widget

A [Label] is a widget for displaying a single line of text.

{5 {{:graph-b_label.html}Dependency graph}}
 *)
module Label : sig
  type t
  type font
  type style

  val create : ?size:int -> ?font:font -> ?style:style ->
               ?fg:Draw.color -> ?align:Draw.align -> string -> t
  (** Create a new {!Label.t}. Most of the tit of the time, you'd rather want to create a
     {!Widget.t} by using {!Widget.label}. *)

  val icon : ?size:int -> ?fg:Draw.color -> string -> t
  (** Create a {!Label.t} using the name of a
     {{:https://lab.artlung.com/font-awesome-sample/}FontAwesome} symbol.  Most
     of the time, you'd rather want to create a {!Widget.t} by using
     {!Widget.icon}. *)

  val set : t -> string -> unit
  (** Modify the text of the label. Does nothing if the given text is already
     the same as the label's previous text. *)

  val set_fg_color : t -> Draw.color -> unit
  (** Modify the color of the text. *)

  val size : t -> int * int
  (** Return the logical size (w,h).
      Warning, a +/- 1 error can be observed due to rounding. *)

end (* of Label *)

(* ---------------------------------------------------------------------------- *)

(** Button widget with text or icon

{5 {{:graph-b_button.html}Dependency graph}}
*)
module Button : sig
  type t
  type kind =
    | Trigger (* one action when pressed. TODO, better to avoid name clash with
                 Trigger module*)
    | Switch (* two states *)

  val create : ?size:int ->
    ?border_radius:int ->
    ?border_color:Draw.color ->
    ?fg:Draw.color ->
    ?bg_on:Style.background ->
    ?bg_off:Style.background ->
    ?bg_over:Style.background ->
    ?label:Label.t ->
    ?label_on:Label.t -> ?label_off:Label.t -> ?state:bool -> string -> t
  val state : t -> bool
  val reset : t -> unit
  val is_pressed : t -> bool
end (* of Button *)

(* ---------------------------------------------------------------------------- *)

(** Slider widget

{5 {{:graph-b_slider.html}Dependency graph}}
 *)
module Slider : sig
  type t
  type  kind =
    | Horizontal (* horizontal bar with a small slider; NO background *)
    | HBar (* horizontal bar filled up to the value *)
    | Vertical
    | Circular

  val size : t -> int * int

  val value : t -> int
  (** Get current value. *)

  val set : t -> int -> unit
  (** Set a new value. *)

end (* of Slider *)

(* ---------------------------------------------------------------------------- *)

(** Checkbox widget

{5 {{:graph-b_check.html}Dependency graph}}
 *)
module Check : sig
  type t
  type style

  val create :  ?state:bool -> ?style:style -> unit -> t
  val state : t -> bool

end (* of Check *)

(* ---------------------------------------------------------------------------- *)

(** Multi-line text display widget

{5 {{:graph-b_text_display.html}Dependency graph}}
 *)
module Text_display : sig
  type t
  type words

  (** {2 Preparing the text} *)

  val example : words
  val raw : string -> words
  val bold : words -> words
  val italic : words -> words
  val normal : words -> words
  val underline : words -> words
  val strikethrough : words -> words
  val page : words list -> words list
  val para : string -> words
  val paragraphs_of_string : string -> words list

  (** {2 Creating the widgets}

       Use {!Widget.text_display}
*)

  (** {2 Modifying the widgets} *)

  val replace : by:t -> t -> unit
(** [replace ~by:t2 t1] replaces the text content of [t1] by the one of [t2]. *)

  val update_verbatim : t -> string -> unit

end (* Text_display *)

(* ---------------------------------------------------------------------------- *)

(** One-line text-input widget

{5 {{:graph-b_text_input.html}Dependency graph}}
 *)
module Text_input : sig
  type t
  type filter = string -> bool

  val uint_filter : filter
  val text : t -> string

end (* of Text_input *)

(* ---------------------------------------------------------------------------- *)

(** Box widget

{5 {{:graph-b_box.html}Dependency graph}}
*)
module Box : sig
  type t

  val create : ?width:int -> ?height:int ->
    ?style:Style.t -> unit -> t

end (* of Box *)

(* ---------------------------------------------------------------------------- *)

(** SDL Area widget

    You can use an Sdl_area widget to draw whatever you want using all the power
    of the
    {{:https://erratique.ch/software/tsdl/doc/Tsdl/Sdl/index.html#renderers}SDL
    renderer API}.

    Technically, an Sdl_area widget contains an SDL texture and sets it as a {e
    render target}.

    SDL commands are sent to the Sdl_area using {!add} (and stored in a command
    queue). You can also use {!add_get} in order to get a handle on the command
    in case you reserve the possibility to remove the command with
    {!remove_element}.

{5 {{:graph-b_sdl_area.html}Dependency graph}} *)
module Sdl_area : sig
  type t

  val create : width:int -> height:int ->
    ?style:Style.t -> ?timeout:int -> unit -> t
  (** Create an empty SDL area. Note that the given size [(width,height)] is the
      {e logical} pixel size of the area. The physical size, to be used for most
      SDL rendering functions, can be obtained with {!drawing_size}. *)

  val update : t -> unit
  (** Force the area to be re-drawn at the next graphics frame. *)

  val clear : t -> unit
  (** Clear the area (this removes all commands from the render queue). *)

  val add : t -> ?name:string -> (Tsdl.Sdl.renderer -> unit) -> unit
  (** [add area ~name f] adds the arbitrary command [f] to the render queue.
     The command should be fast, otherwise it will block the UI when the queue
     is executed. For long drawings, it's better to split them into many
     commands. If you need the possibility to remove a command later, use
     {!add_get} instead. *)

  (** {2 Drawing functions and utilities}

      Shortcuts to some {%html:<a href="Bogue.Draw.html#drawing_functions">
      drawing functions</a>%} from the {!Draw} module.

      For more sophisticated shapes (and faster rendering), consider using the
      {{:https://github.com/fccm/tsdl-gfx}tsdl_gfx} external library or,
      better, the companion {{:https://github.com/sanette/bogue-cairo}bogue-cairo} library.  *)

  val drawing_size : t -> (int * int)
  (** Size in physical pixels of the target SDL texture on which you can
     draw. You may also use [Tsdl.Sdl.get_renderer_output_size], if used inside
      the Sdl_area command queue. *)

  val pointer_pos : t -> Tsdl.Sdl.event -> int * int
  (** Position of the pointer (mouse or touchscreen that has generated the
     event) in physical pixels, with respect to the top-left corner of the
     Sdl_area. Should be called only after the Sdl_area has been rendered. *)

  val to_pixels : (int * int) -> (int * int)
  (** Convert BOGUE logical coordinates into pixel coordinates usable for the
     SDL area. Same as {!Draw.to_pixels}. *)

  val draw_line : t -> color:Draw.color -> thick:int ->
    int * int -> int * int -> unit
  (** [draw_line c ~color ~thick (x1, y1) (x2, y2)] draws a line of given
      [color] and [thick]ness from point [(x1, y1)] to point [(x2, y2)]. *)

  val draw_rectangle : t -> color:Draw.color -> thick:int ->
    w:int -> h:int -> int * int -> unit
  (** [draw_rectangle c ~color ~thick ~w ~h x0 y0] draws a rectangle of the
        given line thickness {e inside} the box of top-left coordinates [(x0,
        y0)], width [w] and height [h]. *)

  val draw_circle : t -> color:Draw.color -> thick:int -> radius:int ->
    int * int -> unit
  (** [draw_circle c ~color ~thick ~radius (x0, y0)] draws a circle of the given
     line [thick]ness and [color] {e inside} the disc of center coordinates
     [(x0, y0)] and given [radius].


      An example of [draw_circle] is provided by Example #50 (it can be run from
     the terminal with [boguex 50]), which produces the following picture:

      {%html:<div class="figure"><img src="images/example50.png"></div>%}

      The source code for all [boguex] examples is
     {{:https://github.com/sanette/bogue/blob/master/examples/example.ml}here}.

*)


  (** {2 Draw elements}

      The command queue can be manipulated. An element of this queue is called a
      [draw_element].  *)

  type draw_element

  val add_get : t -> ?name:string -> ?disable:bool -> (Tsdl.Sdl.renderer -> unit)
    -> draw_element
  (** Similar to {!add}, but returns the corresponding {!draw_element}.  If
     [disable] is true, the command will not be executed. *)

  val disable : draw_element -> unit
  (** Mark an element for skipping its execution. *)

  val enable : draw_element -> unit
  (** See {!disable}. *)

  val remove_element : t -> draw_element -> unit
  (** Remove the {!draw_element} from the command queue. *)

  val add_element : t -> draw_element -> unit
  (** Append the element to the end of the command queue. *)

  val has_element : t -> draw_element -> bool
  (** Check whether the element belongs to the command queue. *)

  (** {2 Direct access to the texture} *)

  val get_texture : t -> Tsdl.Sdl.texture option

  val set_texture : t -> Tsdl.Sdl.texture -> unit

end (* of Sdl_area *)

(* ---------------------------------------------------------------------------- *)

(** Creating widgets and giving life to them

Widgets are simple graphic elements that can react to user interaction. They are
   the inhabitants of your GUI house. When a widget is woken up by some event,
   it can talk to another widget by means of a [connection].

{5 {{:graph-b_widget.html}Dependency graph}} *)
module Widget : sig
  type t
  (** The type {!t} is a union of all kinds of widgets: Box, Button, Check box,
     Image, Label, Slider, Text display, and Text input, plus the Empty
     widget.

For instance, in the following code:
{[
let w = label "Hello" in
let l = get_label w in
...
]}
[w] has the generic {!t} type, while [l] has the specialized {!Label.t} type.
*)

  (** {2:connections Connections}

      A connection has a source widget and a target widget. When the source
     widget receives a specified event, the connection is activated, executing a
     specified function, which is called {!action}.

     An action is always executed in a new Thread (and hence will not block the
     GUI), unless the priority [Main] is specified.  *)

  type connection

  type action = t -> t -> Tsdl.Sdl.event -> unit
  (** An action is a function with three parameters [w1 w2 ev], where
     [w1] is the source widget, [w2] the target widget, and [ev] the event
     ({!Trigger.t}) that triggered the action.

     The action should regularly verify {!Trigger.should_exit}[ ev]
     and quickly exit when this returns [true].
*)

  (** What to do when the same action (= same connection id) is already running? *)

  type action_priority =
    | Forget (** discard the new action *)
    | Join (** execute the new after the first one has completed *)
    | Replace (** kill the first action (if possible) and execute the second one
                 *)
    | Main (** run in the main program. So this is blocking for all subsequent
              actions *)

  val connect : t -> t -> action -> ?priority:action_priority ->
    ?update_target:bool -> ?join:connection -> Trigger.t list -> connection
  (** [connect source target action triggers] creates a connection from the
      [source] widget to the [target] widget, but does not register it ({e this
      may change in the future...}). Once it is registered (either by
      {!Main.make} or {!add_connection}), and assuming that the layout containing
      the source widget has {e focus}, then when an event [ev] matches one of the
      [triggers] list, the [action] is executed with arguments [source target ev].

      @param priority indicates the desired priority policy. Default is [Forget].

  *)

  val connect_main : t -> t -> action ->
    ?update_target:bool -> ?join:connection -> Trigger.t list -> connection
  (** Alias for [connect ~priority:Main]. Should be used for very fast actions
      that can be run in the main thread. *)

  val add_connection : t -> connection -> unit
  (** Registers the connection with the widget. This should systematically be
     done after each connection creation, when the connection is created {e
     after} {!Main.make}.

     Connections that are created {e before} {!Main.make} should rather be
     passed as argument to {!Main.make}, and {e not} via
     [add_connection]. Although this is not striclty necessary, this indicates
     that these connections are more 'pure' or at least more static, in the
     sense that they will not be modified by Bogue. These are usually much
     easier to debug.

     {e [add_connection] is separated from {!connect} because it is not pure: it
     mutates the widget. This might change in future versions.} *)

  val update : t -> unit
  (** [update w] asks the widget [w] to refresh at next frame. The most probable
     use of [update] is within the code of an {!action}. It can happen that the
     action modifies the visual state of a widget that is neither the source or
     the target, and then one needs to explicitly tell this widget to re-draw
     itself.  *)

  (** {3 Predefined connections} *)

  val on_release : release:(t -> unit) -> t -> unit
  (** [on_release ~release:f w] registers on the widget [w] the action [f],
     which will be executed when the mouse button is released on this widget.
      {e Uses [priority=Main]} *)

  val on_click : click:(t -> unit) -> t -> unit
  (** {e Uses [priority=Main]} *)

  val mouse_over : ?enter:(t -> unit) -> ?leave:(t -> unit) -> t -> unit


  (** {2:widget_create Creation of Widgets} *)

  (** {3 Simple boxes (rectangles)} *)

  val box :
     ?w:int -> ?h:int -> ?style:Style.t -> unit -> t
  (** Create a Box widget, which simply displays a rectangle, optionally with
     rounded corners and drop shadow. It is often used for the background of a
     group of widgets (i.e. a {!Layout.t}). *)

  (** {3 Check boxes}
      The standard on/off check boxes. *)

  val check_box : ?state:bool -> ?style:Check.style -> unit -> t
  val set_check_state : t -> bool -> unit

  (** {3 Text display}
      Use this for multi-line text. *)

  val text_display :  ?w:int -> ?h:int -> string -> t
  val rich_text : ?size:int -> ?w:int -> ?h:int -> Text_display.words list -> t
  val verbatim : string -> t

  val html : string -> t
  (** Display basic html text by interpreting the following tags:
      [<em>,</em>, <b>,</b>, <strong>,</strong>, <p>,</p>, <br>] *)

  (** {3 Labels or icons} *)

  val label : ?size:int -> ?fg:Draw.color -> ?font:Label.font ->
    ?align:Draw.align -> string -> t
  (** Create a Label widget with a one-line text. *)

  val icon : ?size:int -> ?fg:Draw.color -> string -> t
  (** Create a Label widget with a
     {{:https://lab.artlung.com/font-awesome-sample/}FontAwesome} icon.

     For instance [icon ~size:24 "star"] creates a widget that displays the
     "fa-star" fontawesome icon. *)

  (** {3 Empty} *)

  val empty : w:int -> h:int -> unit -> t
  (** Create a widget that does not display anything but still gets focus and
     reacts to events. *)

  (** {3 Image} *)

  val image : ?w:int -> ?h:int -> ?bg:Draw.color ->
    ?noscale:bool -> string -> t
  (** Load image file. *)

  val image_from_svg : ?w:int -> ?h:int -> ?bg:Draw.color -> string -> t
  (** Requires [rsvg]. *)

  (** {3 Text input} *)

  val text_input : ?text:string -> ?prompt:string ->
    ?size:int -> ?filter:Text_input.filter -> ?max_size:int -> unit -> t

  (** {3 Buttons} *)

  val button : ?kind:Button.kind -> ?label:Label.t ->
    ?label_on:Label.t -> ?label_off:Label.t ->
    ?fg:Draw.color ->
    ?bg_on:Style.background -> ?bg_off:Style.background ->
    ?bg_over:Style.background ->
    ?state:bool ->
    ?border_radius:int -> ?border_color:Draw.color -> string -> t

  (** {3 Sliders} *)

  val slider : ?priority:action_priority -> ?step:int -> ?value:int ->
    ?kind:Slider.kind ->
    ?var:(int Avar.t, int) Tvar.t ->
    ?length:int -> ?thickness:int -> ?tick_size:int -> ?lock:bool ->
    ?w:int -> ?h:int -> int -> t

  val slider_with_action : ?priority:action_priority ->
    ?step:int -> ?kind:Slider.kind -> value:int -> ?length:int ->
    ?thickness:int -> ?tick_size:int -> action:(int -> unit) -> int -> t
  (** Create a slider that executes an action each time the local value of the
     slider is modified by the user. *)

  (** {3 Sdl Area} You can use an Sdl_area widget to draw whatever you want
     using all the power of the SDL Renderer API. *)

  val sdl_area : w:int -> h:int -> ?style:Style.t -> unit -> t
  (** See {!Sdl_area.create} regarding the size [(w,h)]. *)

  (** {2 Creation of combined widgets} *)

  val check_box_with_label : string -> t * t
  (** [let b,l = check_box_with_label text] creates a check box [b], a label
     [l], and connect them so that clicking on the text will also act on the
     check box. *)

  (** {2 Generic functions on widgets}

      These generic functions work on all types of widgets, and emit an error in
     the log (without raising any exception) whenever the type of the argument
     makes no sense for the function.

      These functions are very handy, but sometimes can hide a bug. For instance
     if you want to use [get_state t], while you know that [t] should always be
     of type [Button], then it will help debugging to use instead the slightly
     longer form {!Button.state}[ (get_button t)]. Indeed the latter will fail
     if [t] happens not to be a Button.

*)

  val get_state : t -> bool
  (** Query a boolean state. Works for Button and Check. *)

  val get_text : t -> string
  (** Return the text of the widget. Works for Button, TextDisplay, Label, and
     TextInput. *)

  val size : t -> int * int
  (** If the widget is not rendered yet, a default size may be returned instead
     of the true size. *)

  val set_state : t -> bool -> unit
  (** Set a boolean state. Works for Button and Check. *)

  val set_text : t -> string -> unit
  (** Change the text of a widget. Works for Button, TextDisplay, Label,
     and TextInput. *)

  (** {2 Conversions from the generic Widget type to the specialized inner type}

     These functions raise [Invalid_argument] whenever their argument is not of
     the correct type.  *)

  val get_box : t -> Box.t
  val get_check : t -> Check.t
  val get_label : t -> Label.t
  val get_button : t -> Button.t
  val get_slider : t -> Slider.t
  val get_text_display : t -> Text_display.t
  val get_text_input : t -> Text_input.t
  val get_sdl_area : t -> Sdl_area.t

  (** {2 Generic actions} *)

  val map_text : (string -> string) -> action
  (** [map_text f] is a {!action} that replaces the text of the second widget
     by [f] applied to the text of the first widget. *)

end (* of Widget *)

(* ---------------------------------------------------------------------------- *)

(** Updating widgets

{5 {{:graph-b_update.html}Dependency graph}}
*)
module Update : sig

  val push : Widget.t -> unit
  (** Register a widget for being updated (at next frame) by the main loop. *)

end (* of Update *)

(* ---------------------------------------------------------------------------- *)


(** {2 Layouts}

    Layouts are rectangular graphical placeholders, in which you should pack all
   your widgets in order to display your GUI. Sophisticated gadgets are usually
   obtained by combining several layouts together.  *)


(** The main, all-purpose graphics container

 A layout is a "box" (a rectangle) whose purpose is to place onscreen the
   various elements composing the GUI. It can contain a single widget, or a list
   of sub-layouts. In Bogue, we use the housing metaphor: a layout is a {b
   house} that contains either a single {b resident}, or several {b rooms}. Each
   room can be seen as a sub-house, and can contain a resident or
   sub-rooms. Houses and rooms have the type {!t}, while a resident has the type
   {!Widget.t}.

     Technically, the usual metaphor in computer science is a {e Tree}. A layout
   is a tree, each vertex (or node) has any number of branches (or children). A
   leaf (terminal node: without any child) is either empty or contains a
   widget. However, the tree is upside-down (as often): we think of the trunk
   (or {e top-layout}) to be a the top, and the leaves at the bottom.

{5 {{:graph-b_layout.html}Dependency graph}} *)
module Layout : sig
  type t

  exception Fatal_error of (t * string)

  type room_content =
    | Rooms of t list
    | Resident of Widget.t

  (** Not implemented. *)
  type adjust   =
  | Fit
  | Width
  | Height
  | Nothing

  (** {2 Backgrounds} *)

  (** Warning, the [background] type corresponds actually to the {!Style.t}
     type, which means is includes color backgrounds, image patterns, corner and
     shadow styles. In fact, any {!Box.t} can be turned into a [background]. *)
  type background

  val color_bg : Draw.color -> background
  (** Construct a background from an RGBA color.*)

  val opaque_bg : Draw.rgb -> background
  (** Construct a background from a RGB (ie non-transparent) color. *)

  val box_bg : Box.t -> background
  (** Construct a background from the given [Box]. *)

  val style_bg : Style.t -> background
  (** Construct a background from the given [Style]. *)

  val theme_bg: background
  (** This is the background constructed from the current theme's BG_COLOR. *)

  val unload_background : t -> unit
  (** Free the texture associated with the background (if any). This can be used
     to force recreating it. *)

  (** {2 Creation of layouts}

      Remark: all layouts have an optional [name] property, which is used only
     for debugging. *)

  val empty : ?name:string -> ?background:background ->
              w:int -> h:int -> unit -> t
  (** An empty layout can reserve some space without stealing focus. *)

  (** {3 Create layouts from widgets} *)

  val resident :
    ?name:string -> ?x:int -> ?y:int -> ?w:int -> ?h:int ->
    ?background:background ->
    ?draggable:bool ->
    ?canvas:Draw.canvas ->
    ?layer:Draw.layer -> ?keyboard_focus:bool -> Widget.t -> t
  val flat_of_w :
    ?name:string -> ?sep:int -> ?h:int ->
    ?align:Draw.align ->
    ?background:background ->
    ?widget_bg:background -> ?canvas:Draw.canvas -> ?scale_content:bool ->
    Widget.t list -> t
  val tower_of_w :
    ?name:string -> ?sep:int -> ?w:int ->
    ?align:Draw.align ->
    ?background:background ->
    ?widget_bg:background -> ?canvas:Draw.canvas -> ?scale_content:bool ->
    Widget.t list -> t

  (** {3 Create layouts from other layouts} *)

  val flat :
    ?name:string -> ?sep:int ->
    ?adjust:adjust -> ?hmargin:int -> ?vmargin:int -> ?margins:int ->
    ?align:Draw.align ->
    ?background:background -> ?shadow:Style.shadow ->
    ?canvas:Draw.canvas -> ?scale_content:bool -> t list -> t
  val tower :
    ?name:string -> ?sep:int ->
    ?margins:int -> ?hmargin:int -> ?vmargin:int ->
    ?align:Draw.align ->
    ?adjust:adjust ->
    ?background:background -> ?shadow:Style.shadow ->
    ?canvas:Draw.canvas -> ?clip:bool -> ?scale_content:bool -> t list -> t
  val superpose :
    ?w:int -> ?h:int -> ?name:string ->
    ?background:background -> ?canvas:Draw.canvas -> ?center:bool ->
    ?scale_content:bool ->
    t list -> t
  (** Create a new layout by superposing a list of layouts without changing
      their (x,y) position. *)

  (** Remark: when creating a house (a layout) with [flat*], [tower*], or
     [superpose], the size of the inner rooms will be automatically updated
     whenever the size of the house is modified. However, as soon as one
     manually sets the size or the position of a room inside this house with
     {!set_width}, {!setx} and alikes, then the room will stop reacting to
     changes of the house size. *)

  (** {2 Some useful layout combinations} *)

  val make_clip : ?w:int ->
    ?scrollbar:bool ->
    ?scrollbar_inside:bool -> ?scrollbar_width:int -> h:int -> t -> t
  (** Clip a layout inside a smaller container and make it scrollable, and
      optionally add a scrollbar widget. *)

  (** {2 Get layout attributes} *)

  val xpos : t -> int
  (** get current absolute x position of the layout (relative to the top-left
     corner of the window). Not necessarily up-to-date. *)

  val ypos : t -> int
  (** see {!xpos} *)

  val width : t -> int
  val height : t -> int
  val get_size : t -> int * int
  (** [get_size l] is equivalent to [(width l, height l)] *)

  val get_physical_size : t -> int * int
  (** multiplies [get_size] by the Theme scaling factor. This gives in principle
     the correct size in physical pixels, up to an error of +/- 1pixel, due to
     rounding error. *)

  val getx : t -> int
  (** Compute the relative x position of the room with respect to its house,
     using animations if any. Because of this, this function should not be
      called by the animation itself! Use {!get_oldx} instead.  *)

  val get_oldx : t -> int
  (** Return the last computed value for the relative x position of the
     layout. *)

  val gety : t -> int
  val get_oldy : t -> int

  val widget : t -> Widget.t
  (** Return the resident widget, or
      @raise Not_found if the layout is not a {e leaf}. *)

  val top_house : t -> t
  (** Return the top of the layout tree (the "house" that contains the given
     layout and that is not contained in another layout). It is the only layout
     that is directly attached to a "physical" (SDL) window. *)

  val get_content : t -> room_content

  val get_rooms : t -> t list

  val has_resident : t -> bool

  (** {2 Modify existing layouts}

      These functions will not work if there is an animation running acting of
     the variable we want to set. Most of these functions will stop the
     automatic resizing mechanism of the room. Use {!auto_scale} to reactivate
     it. *)

  val auto_scale : t -> unit
  (** Set the layout to automatically scale its inner rooms when the layout size
     is modified. *)

  val set_width : ?keep_resize:bool -> ?check_window:bool -> ?update_bg:bool
                  -> t -> int -> unit
  val set_height :  ?keep_resize:bool -> ?check_window:bool -> ?update_bg:bool
                  -> t -> int -> unit
  val set_size :  ?keep_resize:bool -> ?check_window:bool -> ?update_bg:bool
                  -> t -> int * int -> unit
  val setx : ?keep_resize:bool -> t -> int -> unit
  val sety : ?keep_resize:bool -> t -> int -> unit
  val set_show : t -> bool -> unit

  val set_shadow : t -> Style.shadow option -> unit

  val fix_content : t -> unit
  (** Disable automatic resizing of the rooms inside this layout. *)

  val fit_content : ?sep:int -> t -> unit
  (** Adapt the size of the layout (and their houses) to the disposition of the
     contained rooms. *)

  val set_rooms : t -> ?sync:bool -> t list -> unit
  (** Modify the layout content by replacing the former content by a new list of
     rooms. Use [sync=true] (the default) as much as possible in order to avoid
     multi-threading problems. Then the changes will be applied by the main
      thread at next frame (see {!Sync}). *)

  val replace_room : by:t -> t -> unit
  (** Replace "room" by "by" inside "house" in lieu and place of the intial
     room. No size adjustments are made. Of course this is dangerous, because it
     modifies both the house and "by". Beware of circular dependencies... Of
     course this assumes that "room" already belongs to "house". *)

  val unload_textures : t -> unit
  (** Use this to free the textures stored by the layout (and its children) for
     reducing memory. The layout can still be used without any impact, the
     textures will be recreated on the fly.  *)

  val lock : t -> unit
  val unlock : t -> unit
  (** Since layouts can be modified by different threads, it might be useful to
     lock it with a mutex. This does *not* always prevent from modifying it, but
     another [lock] statement will wait for the previous lock to be removed by
     {!unlock}. *)

  val push_close : t -> unit
  (** Emit the close-window event to the window containing the layout. This
     should close the window at the next graphics frame. *)


  (** {2 Animations}

      Position, size, alpha channel, and rotation of Layouts use [Avar]
     variables and hence can be easily animated. Most predefined animations have
      a default duration of 300ms. *)

  (** {3 Generic animations}

      These functions assign an animated variable if type {!Avar.t} to one
     of the properties of the layout (position, width, etc.)  *)

  val animate_x : t -> int Avar.t -> unit
  (** Assign an Avar to the layout x position. *)

  val animate_y : t -> int Avar.t -> unit
  val stop_pos : t -> unit
  (** Stop animations of the variables x and y. *)

  val animate_w : t -> int Avar.t -> unit
  val animate_h : t -> int Avar.t -> unit
  val animate_alpha : t -> float Avar.t -> unit
  val animate_angle : t -> float Avar.t -> unit

  (** {3 Predefined animations} *)

  val hide : ?duration:int -> ?towards:Avar.direction -> t -> unit
  (** See {!show}. *)

  val show : ?duration:int -> ?from:Avar.direction -> t -> unit
  (** Does nothing if the layout is already fully displayed. Only the
     [Avar.Top] and [Avar.Bottom] directions are currently implemented. For
     these directions, [hide] and [show] do {e not} modify the position
     variables (x,y) of the layout, they use a special variable called
     [voffset]. *)

  val fade_in : ?duration:int -> ?from_alpha:float -> ?to_alpha:float ->
    t -> unit
  (** Animate the alpha channel of the layout. Can be combined with animations
     involving the other animated variables. Does {e not} modify the [show]
     status of the layout. By default, [from_alpha=0.] (transparent) and
      [to_alpha=1.]  (opaque).  *)

  val fade_out : ?duration:int ->
    ?from_alpha:float -> ?to_alpha:float -> ?hide:bool -> t -> unit
  (** See {!fade_in}. WARNING: fading out to alpha=0 results in a completely
     transparent layout, but the layout is {e still there} (it's not
     "hidden"). Which means it can still get mouse focus. If you want to hide
     it, then use [hide=true]. By default, [hide=false], [from_alpha] is the
     current alpha of the layout, and [to_alpha=0.] *)

  val rotate : ?duration:int -> ?from_angle:float -> angle:float -> t -> unit
  (** Rotate all widgets inside the layout around their respective centers. For
      a global rotation, use a {!Snapshot}. *)

  val slide_in : ?from:Avar.direction -> dst:t -> t -> unit
  val slide_to : ?duration:int -> t -> int * int -> unit
  (** [slide_to room (x0,y0)] will translate the [room] to the position
     [(x0,y0)]. *)

  val follow_mouse : ?dx:int -> ?dy:int ->
    ?modifierx:(int -> int) -> ?modifiery:(int -> int) -> t -> unit
  val oscillate : ?duration:int -> ?frequency:float -> int -> t -> unit
  val zoom : ?duration:int -> from_factor:float -> to_factor:float -> t -> unit

  val reflat : ?align:Draw.align ->
    ?hmargin:int -> ?vmargin:int -> ?margins:int -> ?duration:int -> t -> unit
  (** Adjust an existing layout to arrange its rooms in a "flat" fashion, as if
     they were created by {!Layout.flat}. Will be animated if [duration <> 0]. *)

  val retower : ?align:Draw.align ->
    ?hmargin:int -> ?vmargin:int -> ?margins:int -> ?duration:int -> t -> unit

  (** {2 Windows}

      A very special use of layout is to represent the 'window' on which
     everything is drawn. Thus, this specific to the 'main house' (or {e
     top-layout}), {e i.e.} a layout that is not a sublayout of another
     layout. *)

  val window : t -> Tsdl.Sdl.window

  val set_window_pos : t -> int * int -> unit
  (** It should be set {b after} {!Main.make} and {b before}
     {!Main.run}. Otherwise it has possibly no effect, or perhaps causes some
      glitches.  *)

  (** {2 Misc} *)

  val set_cursor : t option -> unit
  (** Sets the cursor to the default value for this layout. *)

end (* of Layout *)

(* ---------------------------------------------------------------------------- *)

(** Adjust various spacings and sizes of layouts

These functions {e do not take effect immediately!} They will be executed, in
   the order of their invocation, at the next graphics frame (or at startup if
   they are invoked before the start of the mainloop).

{5 {{:graph-b_space.html}Dependency graph}}
 *)
module Space : sig

  val hfill : ?right_margin:int -> unit -> Layout.t
      (** When used in a {!Layout.flat} structure, this special empty layout will
     automatically expand in order to fill the available width in the parent
     house. The other inhabitants keep the width they had at the execution of
     the [hfill] invocation. Their height is resized as usual. Only one [hfill]
     layout should be used in a given house. *)


  val make_hfill : ?right_margin:int -> Layout.t -> unit
  val full_width : ?right_margin:int -> ?left_margin:int -> Layout.t -> unit
     (** This will set the width of the room (layout) in order to occupy the whole
     width of its house. *)

  val make_vfill : ?bottom_margin:int -> Layout.t -> unit
 (** Like {!hfill}, but applies to the specified layout instead of creating an
      empty one. *)

  val vfill : ?bottom_margin:int -> unit -> Layout.t
    (** When used in a {!Layout.tower} structure, this special empty layout will
     automatically expand in order to fill the available height in the parent
     house. See {!hfill}. *)

  val full_height : ?top_margin:int -> ?bottom_margin:int -> Layout.t -> unit

  val keep_bottom : ?reset_scaling:bool -> ?margin:int -> Layout.t -> unit

  val keep_right : ?reset_scaling:bool -> ?margin:int -> Layout.t -> unit


end (* of Space *)

(* ---------------------------------------------------------------------------- *)

(** Convert Bogue objects to strings for debugging

{5 {{:graph-b_print.html}Dependency graph}}
*)
module Print : sig

  val layout_down : ?indent:string -> Layout.t -> string
  (** Print a layout with all its rooms and subrooms (children). *)

  val layout_up : ?indent:string -> Layout.t -> string
  (** Print the layout node and all the rooms (houses, or parents) in which it
      is contained. *)

  val layout_error : Layout.t -> string -> unit
  (** Print a message to stderr and dump the top_house structure to a temporary
     file. *)

end (* of Print *)

(* ---------------------------------------------------------------------------- *)

(** Create an image from a Layout

{5 {{:graph-b_snapshot.html}Dependency graph}}
*)
module Snapshot : sig

  val create : ?border:Style.border -> Layout.t -> Widget.t
  (** Should be called from the main thread only. There are some issues with
     transparency.
     @return a Box widget. *)

end (* of Snapshot *)

(* ---------------------------------------------------------------------------- *)

(** Handle large lists by not displaying all elements at once

Very quickly, displaying a list of layouts (for instance, listing files in a
   directory) can run the computer out of memory if it tries to keep in memory
   the textures of {b all} entries of the list. In these cases you need to use a
   [Long_list].

See for instance the example 34: `boguex 34` that displays a list of 1 million
   entries.

Long_lists may contain any type of Layout. They don't need to be all of the same
   dimension. Instead of providing the list of layouts, one must give a function
   [generate] such that the layout given by [generate i] is the i-eth element of
   the list.

{5 {{:graph-b_long_list.html}Dependency graph}} *)
module Long_list : sig
  type t

  val create : w:int -> h:int -> length:int ->
    ?first:int ->
    generate:(int -> Layout.t) ->
    ?height_fn:(int -> int option) ->
    ?cleanup:(Layout.t -> unit) ->
    ?max_memory:int ->
    ?linear:bool -> ?scrollbar_width:int -> unit -> Layout.t
  (** Create a long list through the function [generate] which maps any index
     {e i} to the {e ieth} element (layout) of the list. If specified (which is
     not a good idea), the [max_memory] should be at least twice the area (in
     physical pixels) of the visible part of the list. If the number of elements
     is large (typically 100000 or more, this depends on your CPU), its is
     highly advisable to provide a [height_fn], which to an index {e i} gives
     the height (in logical pixels) of the {e ieth} entry. If some heights are
     not known in advance, it's ok to return [None]. For instance, if all
     entries have the same height, say 30 pixels, one can define

      {[ let height_fn _ = Some 30 ]} *)

end (* of Long_list *)

(* ---------------------------------------------------------------------------- *)

(** Switch between layouts using Tabs

{5 {{:graph-b_tabs.html}Dependency graph}}
*)
module Tabs : sig

  val create :
    ?slide:Avar.direction ->
    ?adjust:Layout.adjust -> ?expand:bool ->
    ?canvas:Draw.canvas ->
    ?name:string -> (string * Layout.t) list -> Layout.t
end (* of Tabs *)

(* ---------------------------------------------------------------------------- *)

(** Put layouts on top of others

{5 {{:graph-b_popup.html}Dependency graph}} *)
module Popup : sig

  val add_screen : ?color:Draw.color -> Layout.t -> Layout.t
  (** Add a screen on top of the layout. This can be useful to make the whole
     layout clickable as a whole.
     @return the screen. *)

  (** Generic modal type popup *)
  val attach : ?bg:Draw.color ->
    ?show:bool -> Layout.t -> Layout.t -> Layout.t
  (** [attach house layout] adds two layers on top of the house: one for the
     screen to hide the house, one for the layout on top of the screen.
     @return the screen. *)

  val info : ?w:int -> ?h:int -> ?button:string -> string -> Layout.t -> unit
  (** Add to the layout a modal popup with a text and a close button. By
     default, [button="Close"]. *)

  val yesno : ?w:int -> ?h:int ->
    ?yes:string -> ?no:string ->
    yes_action:(unit -> unit) ->
    no_action:(unit -> unit) -> string -> Layout.t -> unit
  (** Add to the layout a modal popup with two yes/no buttons. By default,
      [yes="Yes"] and [no="No"]. *)

  val two_buttons : ?w:int -> ?h:int -> label1:string -> label2:string ->
    action1:(unit -> unit) -> action2:(unit -> unit) ->
    Layout.t -> Layout.t -> unit

  type position =
  | LeftOf
  | RightOf
  | Above
  | Below
  | Mouse

  val tooltip : ?background:Layout.background ->
    ?position:position ->
    string -> target:Layout.t -> Widget.t -> Layout.t -> unit
  (** [tooltip text ~target widget layout] adds a tooltip which will appear on
     [layout], next to [target] (which should be a sublayout of [layout]), when
     the [widget] gets mouse focus and mouse is idle for some time on it. A
     tooltip it not a modal popup, it does not prevent from interacting with the
     rest of the layout. *)

end (* of Popup *)

(* ---------------------------------------------------------------------------- *)

(** Various types of menus

The generic {!create} function produces menus whose entries can be arbitrary
   layouts located at arbitrary places. But for usual entries, it is enough to
   provide a string for the entry label, and the layout will be constructed
   automatically.

The specialized {!bar} function will produce a familiar menu bar with drop-down
   submenus.

{5 {{:graph-b_menu.html}Dependency graph}}
*)
module Menu : sig

  type t
  (* The type of generic menus. *)

  type action = unit -> unit

  type label =
    | Text of string
    | Layout of Layout.t

  type entry = {
      label : label;
      content : content }

  and content =
    | Action of action
    | Flat of entry list
    (** A Flat content will produce a horizontal menu *)
    | Tower of entry list
    (** A Tower content will produce a vertical menu *)
    | Custom of entry list
    (** In a Custom content, only Layout labels should be used, and their
       position should be defined before creating the menu. *)
    | Separator
    (** Currently only used for inserting separator lines in Tower menus. *)

  val create : ?dst:Layout.t -> content -> t
(** Generic menu creation, inserted in the [dst] layout. *)

  val add_bar : dst:Layout.t -> entry list -> unit
  (** Creation of a menu bar in the [dst] layout, with drop-down submenus.
      [bar dst entries] inserts a layout which contains the menu bar into the top of
      the [dst] layout (so, some room should be provided). The [dst] layout
      should be big enough to contain the submenus. Any item flowing out of [dst]
      will not get focus. *)

  val bar : entry list -> Layout.t
  (** Return a menu layout that will be installed with {!add_bar} into the top
     house at startup. *)

  val separator : entry

end

(* ---------------------------------------------------------------------------- *)

(** Drop-down select list

It's the usual select box which opens a drop-down list when clicked on, similar
   to the [<select>] html tag.

 Under the hood, a select list is a special type of menu with a single entry
   having a submenu.

{5 {{:graph-b_select.html}Dependency graph}} *)
module Select : sig

  val create : ?dst:Layout.t ->
    ?name:string ->
    ?action:(int -> unit) ->
    ?fg:Draw.color ->
      string array -> int -> Layout.t
  (** [create string_array i] creates a select box with preselected entry
     [i]. For instance [create [| "A"; "B"; "C" |] 1] will create a select box
     with default choice ["B"]. The [action] (if specified) is executed when an
     item is selected, and takes as argument the index of the selected item.

        @return a layout showing the selected item. *)

end (* of Select *)

(* ---------------------------------------------------------------------------- *)

(** Check list with a single choice

    Each item of the list is displayed with a 'radio button' in front of it, and
   at most one item can be selected, similarly to [<input type="radio"...>] in
   html. Radiobuttons are implemented with {!Check.t}.

{5 {{:graph-b_radiolist.html}Dependency graph}}
*)
module Radiolist : sig
  type t

  val vertical : ?name:string -> ?click_on_label:bool -> ?selected:int -> string array -> t
  (** A radiolist with the usual vertical layout of items. The option [click_on_label] is true be default: one can click on the label to select it. *)

  val of_widgets : ?selected:int -> Widget.t list -> t

  val layout : t -> Layout.t
  (** The layout to display the radiolist. *)

  val get_index : t -> int option
  val set_index : t -> int option -> unit
  (** Set the selected entry to the specified index and directly activate the
     button's connections with the {!Trigger.var_changed} event. *)

  val active_widgets : t -> Widget.t list
  (** @return the list of widgets that are active for selecting entries ({e
     i.e.} either radiobuttons or radiobuttons and labels, depending on
     [click_on_label]. *)
end (* of Radiolist *)

(* ---------------------------------------------------------------------------- *)

(** Tables with sortable columns and selectable rows

{5 {{:graph-b_table.html}Dependency graph}}
*)
module Table : sig
  type column =
    { title : string;
      length : int;
      rows : int -> Layout.t;
      compare : (int -> int -> int) option;
      (* use "compare i1 i2" in order to compare entries i1 and i2 *)
      width : int option;
    }
  type t

  val create : ?w:int -> h:int -> ?row_height:int ->
    ?name:string ->
    column list -> Layout.t * (Selection.t, Selection.t) Tvar.t
  (** @return a layout and a Tvar. The Tvar can be used to see which rows were
      selected by the user, and also to modify the selection if needed. *)

  val of_array : ?w:int ->
    h:int ->
    ?widths:int option list ->
    ?row_height:int ->
    ?name:string ->
    string list ->
    string array array -> Layout.t * (Selection.t, Selection.t) Tvar.t

  val of_list :
    ?w:int ->
    h:int ->
    ?widths:int option list ->
    ?row_height:int ->
    ?name:string ->
    string list list -> Layout.t * (Selection.t, Selection.t) Tvar.t

end (* of Table *)

(* ---------------------------------------------------------------------------- *)

(** {2 The Bogue mainloop}

Because a GUI continuously waits for user interaction, everything has to run
   inside a loop.  *)

(** Control the workflow of the GUI mainloop

{5 {{:graph-b_main.html}Dependency graph}}
*)
module Main : sig
  type board
  (** The board is the whole universe of your GUI. It contains everything. *)

  exception Exit
  (** Raising the [Exit] exception will tell the GUI loop to terminate. *)

  val exit_on_escape : int * int * (board -> unit)
  (** If the [exit_on_escape] shortcut is given to the {!make} function, then
     the {!Exit} exception will be raised upon pressing the Escape key. *)

  val make : ?shortcuts:(int * int * (board -> unit)) list ->
    Widget.connection list -> Layout.t list -> board
  (** Create a [board] from a list of layouts and connections. The list of
     connections can be empty, because connections can be added afterwards. Each
     Layout in the list will open as a new window. The optional argument
     [shortcuts] is a list of shortcut triples of the form [keycode, keymod,
     action].  *)

  val run :
    ?before_display:(unit -> unit) ->
    ?after_display:(unit -> unit) -> board -> unit
  (** Launch the main loop. *)

  (** {2 Using Bogue together with another graphics loop}

      See the [embed] example. *)

  val make_sdl_windows : ?windows:Tsdl.Sdl.window list -> board -> unit
  (** This is only useful if you have your own graphics loop, and do {e not} use
     {!run}. This function creates an SDL window for each top layout in the
     board. One can use predefined windows with the optional argument
     [windows]. They will be used by the layouts in the order they appear in the
     list. If there are fewer windows than layouts, new windows are created. If
      there are more, the excess is disregarded. *)

  val refresh_custom_windows : board -> unit
  (** Ask the GUI to refresh (ie. repaint) the custom windows (those that were
     not created by Bogue itself). *)

  val one_step : ?before_display:(unit -> unit) ->
    bool -> (unit -> unit) * (unit -> unit) -> ?clear:bool -> board -> bool
(** This is only useful if you have your own graphics loop, and do {e not} use
   {!run}. Calling [one_step ~before_display anim (start_fps, fps) ~clear board]
   is what is executed at each step of the Bogue mainloop. If [anim=true] this
   step is {e non blocking}; this is what you want if either Bogue or your loop
   has an animation running. If [anim=false] then the function will wait until
   an event is received.
   @return [true] if the GUI currently handles an animation. In this case
   [fps()] was executed by [one_step]. If not, you should handle the frame rate
   yourself. *)

  val get_frame : unit -> int
  (** Number of displayed frames since startup. *)

  val quit : unit -> unit
(** Use this to close SDL windows and cleanup memory, after {!run} has
   returned. *)

end (* of Main *)

(* ---------------------------------------------------------------------------- *)

(** Alias for {!Main} *)
module Bogue = Main

(* ---------------------------------------------------------------------------- *)

(** {2:example Example}

    Here is a minimal example with a label and a check box.

{[
open Bogue
module W = Widget
module L = Layout

let main () =

  let b = W.check_box () in
  let l = W.label "Hello world" in
  let layout = L.flat_of_w [b;l] in

  let board = Bogue.make [] [layout] in
  Bogue.run board;;

let () = main ();
  Bogue.quit ()
]}

This can be compiled to bytecode with

{v
ocamlfind ocamlc -package bogue -linkpkg -o minimal -thread minimal.ml
v}

and to native code with

{v
ocamlfind ocamlopt -package bogue -linkpkg -o minimal -thread minimal.ml
v}

Then execute the compiled code:

{v
./minimal
v}

A window should open which should look like this:

{%html:<div class="figure"><img src="minimal.png"></div>%}

You may also evaluate this code in a Toplevel! (for instance [utop], or in an [emacs] session...). Just insert

{v
#thread;;
#require "bogue";;
v}

at the top, then paste the example code above, and add [;;] at the end.

  *)
